) 假设1：整型（int）变量不能与浮点型（float）变量相互赋值或者相互运算。
2) 假设2：仅有int型变量才能进行逻辑运算或者作为if和while语句的条件；仅有int型和
float型变量才能参与算术运算。
3) 假设3：任何函数只进行一次定义，无法进行函数声明。
4) 假设4：所有变量（包括函数的形参）的作用域都是全局的，即程序中所有变量均不能
重名。
5) 假设5：结构体间的类型等价机制采用名等价（Name Equivalence）的方式。
6) 假设6：函数无法进行嵌套定义。
7) 假设7：结构体中的域不与变量重名，并且不同结构体中的域互不重名。
以上假设1至7也可视为要求，违反即会导致各种语义错误，不过我们只对后面讨论的17种
错误类型进行考察。此外，你可以安全地假设输入文件中不包含注释、八进制数、十六进制
数、以及指数形式的浮点数，也不包含任何词法或语法错误（除了特别说明的针对选做要求的
测试）。
你的程序需要对输入文件进行语义分析（输入文件中可能包含函数、结构体、一维和高维
数组）并检查如下类型的错误：
1) 错误类型1：变量在使用时未经定义。
46
2) 错误类型2：函数在调用时未经定义。
3) 错误类型3：变量出现重复定义，或变量与前面定义过的结构体名字重复。
4) 错误类型4：函数出现重复定义（即同样的函数名出现了不止一次定义）。
5) 错误类型5：赋值号两边的表达式类型不匹配。
6) 错误类型6：赋值号左边出现一个只有右值的表达式。
7) 错误类型7：操作数类型不匹配或操作数类型与操作符不匹配（例如整型变量与数组变
量相加减，或数组（或结构体）变量与数组（或结构体）变量相加减）。
8) 错误类型8：return语句的返回类型与函数定义的返回类型不匹配。
9) 错误类型9：函数调用时实参与形参的数目或类型不匹配。
10) 错误类型10：对非数组型变量使用“[…]”（数组访问）操作符。
11) 错误类型11：对普通变量使用“(…)”或“()”（函数调用）操作符。
12) 错误类型12：数组访问操作符“[…]”中出现非整数（例如a[1.5]）。
13) 错误类型13：对非结构体型变量使用“.”操作符。
14) 错误类型14：访问结构体中未定义过的域。
15) 错误类型15：结构体中域名重复定义（指同一结构体中），或在定义时对域进
行初始化（例如struct A { int a = 0; }）。
16) 错误类型16：结构体的名字与前面定义过的结构体或变量的名字重复。
17) 错误类型17：直接使用未定义过的结构体来定义变量。
其中，要注意三点：一是关于数组类型的等价机制，同C语言一样，只要数组的基类型和
维数相同我们即认为类型是匹配的，例如int a[10][2]和int b[5][3]即属于同一类型；二是我们
允许类型等价的结构体变量之间的直接赋值（见后面的测试样例），这时的语义是，对应的域
相应赋值（数组域也如此，按相对地址赋值直至所有数组元素赋值完毕或目标数组域已经填
满）；三是对于结构体类型等价的判定，每个匿名的结构体类型我们认为均具有一个独有的隐
藏名字，以此进行名等价判定。

2) 要求2.2：修改前面的C语言假设4，使其变为“变量的定义受可嵌套作用域的影响，
外层语句块中定义的变量可在内层语句块中重复定义（但此时在内层语句块中就无法访问到外
层语句块的同名变量），内层语句块中定义的变量到了外层语句块中就会消亡，不同函数体内
定义的局部变量可以相互重名”。在新的假设4下，完成错误类型1至17的检查。
3) 要求2.3：修改前面的C语言假设5，将结构体间的类型等价机制由名等价改为结构等
价（Structural Equivalence）。例如，虽然名称不同，但两个结构体类型struct a { int x; float
y; }和struct b { int y; float z; }仍然是等价的类型。注意，在结构等价时不要将数组展开来判
断，例如struct A { int a; struct { float f; int i; } b[10]; }和struct B { struct { int i; float f; } b[10];
int b;}是不等价的。在新的假设5下，完成错误类型1至17的检查。
